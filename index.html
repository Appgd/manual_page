# ファイバ計算Pythonライブラリマニュアル

- [ファイバ計算Pythonライブラリマニュアル](#ファイバ計算pythonライブラリマニュアル)
- [](#)
  - [ファイバ計算用Pythonライブラリ](#ファイバ計算用pythonライブラリ)
    - [断面解析](#断面解析)
      - [構造を決めるlpsファイルの書き方](#構造を決めるlpsファイルの書き方)
      - [有限要素法の設定ファイルであるcfgファイルの書き方](#有限要素法の設定ファイルであるcfgファイルの書き方)
      - [2次元スカラ有限要素法に必要なファイル](#2次元スカラ有限要素法に必要なファイル)
      - [有限要素法の実行ファイル](#有限要素法の実行ファイル)
      - [結合係数の実行ファイル](#結合係数の実行ファイル)
      - [突き合わせ結合係数の実行ファイル](#突き合わせ結合係数の実行ファイル)
    - [伝搬解析](#伝搬解析)
      - [伝搬行列Mの求め方1](#伝搬行列mの求め方1)
      - [基底変換行列Pの求め方](#基底変換行列pの求め方)
      - [伝搬行列Mの求め方2](#伝搬行列mの求め方2)
      - [伝搬解析用C++プログラムの使い方](#伝搬解析用cプログラムの使い方)
        - [伝搬解析を実行するシェルスクリプト`mpiexec.sh`](#伝搬解析を実行するシェルスクリプトmpiexecsh)
        - [伝搬解析を行う計算機を指定する設定ファイル`hostfile`](#伝搬解析を行う計算機を指定する設定ファイルhostfile)
        - [伝搬解析のパラメータを記述した設定ファイル`param.ini`](#伝搬解析のパラメータを記述した設定ファイルparamini)
        - [基底変換行列を格納したファイル`tableU.dat`](#基底変換行列を格納したファイルtableudat)
        - [スーパーモードの伝搬定数を格納したファイル`tablekx.dat`](#スーパーモードの伝搬定数を格納したファイルtablekxdat)
        - [スーパーモードの群屈折率を格納したファイル`tableng.dat`](#スーパーモードの群屈折率を格納したファイルtablengdat)
    - [Tips](#tips)
      - [分散曲線とモード数](#分散曲線とモード数)
      - [並列計算の方法](#並列計算の方法)
      - [よくあるグラフの描画方法](#よくあるグラフの描画方法)
  - [ライブラリの説明](#ライブラリの説明)
    - [fiber.calc\_fiber](#fibercalc_fiber)
      - [各引数の説明](#各引数の説明)
      - [出力ファイルの場所](#出力ファイルの場所)
      - [返り値](#返り値)
    - [pmpy.calc\_gds](#pmpycalc_gds)
      - [各引数の説明](#各引数の説明-1)
      - [出力ファイルの場所](#出力ファイルの場所-1)
      - [返り値](#返り値-1)
    - [fiber.calc\_rbend\_gds](#fibercalc_rbend_gds)
    - [fiber.generate\_hash(gene\_dict)](#fibergenerate_hashgene_dict)

#
## ファイバ計算用Pythonライブラリ
### 断面解析
#### 構造を決めるlpsファイルの書き方
#### 有限要素法の設定ファイルであるcfgファイルの書き方
#### 2次元スカラ有限要素法に必要なファイル
- Ncore.msh, Ncore.cfg
#### 有限要素法の実行ファイル
- `Solver/new_2D_SFEM_20210604b/sfem {N}core`
#### 結合係数の実行ファイル
- `Solver/new_2D_SFEM_overlap/sfem_overlap single{N}/{N}core couple/{N}core`
#### 突き合わせ結合係数の実行ファイル
- `Solver/new_2D_SFEM_overlap_kappa/sfem_overlap single{i}/{N}core single{j}/{N}core couple/{N}core`

### 伝搬解析
#### 伝搬行列Mの求め方1
有限要素法から計算した、個別コアモードの伝搬定数と、結合係数から次式の行列Mを構成する。
$$
M = 
\begin{pmatrix}
\beta_1 & \kappa_{12} & \cdots & \kappa_{1n}\\
\kappa_{21} & \beta_2 & \cdots & \kappa_{2n}\\
\vdots & \vdots & \cdots & \ddots\\
\kappa_{n1} & \kappa_{n2} & \cdots & \beta_n\\
\end{pmatrix}
$$ 
#### 基底変換行列Pの求め方
行列Mを特異値分解すると次式となる。
$$
M = PDP^{\dagger}\\
P = \begin{pmatrix}
c_{11} & \cdots & c_{1n}\\
\vdots & \ddots & \vdots\\
c_{n1} & \cdots & c_{nn}
\end{pmatrix}, 
D = \begin{pmatrix}
\tilde\beta_1 &   & O\\
  & \ddots &  \\
O &  &  \tilde\beta_n\\
\end{pmatrix}
$$ 
$\dagger$は共役複素転置を表す。このとき、Pが基底変換行列、Dが固有値行列となる。Dは対角成分のみを持つ行列で、その要素はスーパーモードの伝搬定数となる。
#### 伝搬行列Mの求め方2
  基底変換行列と固有値行列がわかれば、結合係数$\kappa$を求めずに、突合せ結合係数とスーパーモードの伝搬定数のみからモード結合方程式の行列Mを構成できる。
#### 伝搬解析用C++プログラムの使い方
##### 伝搬解析を実行するシェルスクリプト`mpiexec.sh`
  
```sh
#!/bin/sh
mpirun -n {num_proc} -ppn {num_procpernode} -f hostfile {path_to_lib}/Solver/{PManalysis_dirname}/PManalysis_new param.ini {option}
```
- {num_proc}: 用いるCPUの数
- {num_procpernode}: 用いるメモリ[GB]の量
- {path_to_lib}: 実行ファイルが置かれているライブラリまでのパス．例：`path_to_lib = "/home/konishi/lib"`
- {PManalysis_dirname}: 伝搬解析に用いるC++ファイルの実行ファイルのディレクトリ名
- {option}: 伝搬解析の実行ファイルPManalysis_newのオプション．オプション`-ave`を使うと

ファイル例
```sh
#!/bin/sh
mpirun -n 20 -ppn 10 -f hostfile /home/konishi/lib/Solver/PManalysis_sato_quad_new5_neff/PManalysis_new param.ini -ave
```


##### 伝搬解析を行う計算機を指定する設定ファイル`hostfile`

```sh
{server_name}
```

`{server_name}`: 計算機名
例：hp18, hp20, ts1

ファイル例
```sh
hp18
```

##### 伝搬解析のパラメータを記述した設定ファイル`param.ini`
```
[PManalysis_new5]
data.modenum:	4
center_xy[um]:	+0.0	+0.0
mode0(px,py):	10.0	0.0
mode1(px,py):	0.0	10.0
mode2(px,py):	-10.0	0.0
mode3(px,py):	0.0	-10.0
BetaList:	tablekx.dat
NgList:	tableng.dat
BasisConversionMap:	tableU.dat
distance[m]:	1000
dz[m]:	0.001
Rbend[mm]:	10
RandomBend(sigma)[/mm]:	0
TwistRate[rad/m](1.0:PI):	1.0
RandomTwist(sigma)[rad/m](1.0:PI):	0
Lc[m]:	0.1
```
##### 基底変換行列を格納したファイル`tableU.dat`
```
0.500993420914207	0.500529538098675	0.497425018803623	0.501043036223103
0.695126072491569	0.120723450262004	-0.697971352263144	-0.122725642765954
-0.122479107994722	0.698092500947157	0.120968690401317	-0.695005254723534
-0.500803557942577	0.49755692153653	-0.500770324630727	0.50086124662095
```
- 突き合わせ結合係数`cij/MSH{i}_MSH0/c12_re` i = 1, ..., Nのファイルを読み込み，$n\times n$の基底変換行列$U$を構成する．
$$
c_i = \begin{pmatrix}c_{i1}\\ \vdots \\ c_{in}\end{pmatrix}, 
U = \begin{pmatrix}c_1 \cdots c_n\end{pmatrix}
$$

##### スーパーモードの伝搬定数を格納したファイル`tablekx.dat`
```
5.865236836628815
5.864654482336022
5.864654481157570
5.864105535290867
```
- スーパーモード (couple) の伝搬定数を大きい順で上から並べたファイルです．

##### スーパーモードの群屈折率を格納したファイル`tableng.dat`
```
1.449410803711804
1.449940829048378
1.449940828752061
1.450437689530682
```
- `tablekx.dat`の各モードに対応する群屈折率．順番は`tablekx.dat`の各モードに対応する順．

### Tips
#### 分散曲線とモード数
- 単一コアあたりに伝搬するモード数を決めるときは、所望のモード数となる構造の条件を分散曲線から求める。
#### 並列計算の方法
- Pythonの場合は種々の方法があるが、`multiprocessing`ライブラリを用いている。
#### よくあるグラフの描画方法
- GDSの伝搬距離依存性
- GDSの曲げ半径依存性
- neffの伝搬距離依存性
- GDSスロープの伝搬距離依存性
- GDSスロープの曲げ半径依存性
- カラーマップ


## ライブラリの説明
### fiber.calc_fiber
`result = calc_fiber(structure_dict, gif = False, pdf = False, couple = True, single = True, cij = True, kij = True, table = False)`

ステップインデックス型光ファイバの断面解析を行い，結果を格納した辞書`result`を返します．また，新たに`data`ディレクトリを作成し，計算結果ファイルを出力します．

#### 各引数の説明
`structure_dict`は，解析したいステップインデックス型光ファイバの構造を記述した辞書です．以下の例のように，6つのキーを指定します．

```python
structure_dict = {
    'num_of_core': 4,
    'core_radius': [4.55, 4.55, 4.55, 4.55],
    'x_list': [10, 0, -10, 0],
    'y_list': [0, 10, 0, -10],
    'coredeltas': [0.35, 0.35, 0.35, 0.35],
    'wavelength[um]': 1.55
}
```

- `num_of_core`はコア数を表す整数型 (int) 型のパラメータです．
- `core_radius`はコア径を表すリスト型のパラメータで，リストの要素はfloat型です．単位はμmです．リストの長さはコア数と同じです．
- `x_list`はコアのx座標を表すリスト型のパラメータで，リストの要素はfloat型です．単位はμmです．リストの長さはコア数と同じです．
- `y_list`はコアのx座標を表すリスト型のパラメータで，リストの要素はfloat型です．単位はμmです．リストの長さはコア数と同じです．
- `coredeltas`はクラッドに対するコアの比屈折率を表すリスト型のパラメータで，リストの要素はfloat型です．単位は%です．リストの長さはコア数と同じです．
- `wavelength[um]`は解析波長を表すfloat型のパラメータで，単位はμmです．

#### 出力ファイルの場所
`data`ディレクトリ内に構造ごとのディレクトリが作成され、出力データが格納されます。
構造ごとのディレクトリ名は、入力した`structure_dict`から決定されます。具体的には、読み込んだデータから構成した文字列をさらにハッシュ化した文字列がディレクトリ名となります．ハッシュ化に必要なデータは次の4種類です．小数点3桁までが反映されます。小数点4桁目は四捨五入されます。

- コア径
- x座標
- y座標
- コアの比屈折率
<!-- 
```python
# ハッシュ化の関数 lib/python/fiber/binary_search.py
def generate_hash(gene):
    data = {
            'num_of_core': 2,
            'core_radius': [-1, -1],
            'x_list': [-1, -1],
            'y_list': [-1, -1],
            'coredeltas': [-1, -1],
            'wavelength[um]': -1
        }
    
    # if key is not in gene, raise error
    for key in data.keys():
        if key not in gene.keys():
            raise KeyError(f'{key} not found! {key} is necessary for generating hash')
        
    # if value is negative, raise error
    for key in data.keys():
        if key == 'core_radius' or key == 'coredeltas':
            for i in range(len(gene[key])):
                if gene[key][i] < 0:
                    raise ValueError(f'{key} is negative')
        elif type(gene[key]) == float or type(gene[key]) == int:
            if gene[key] < 0:
                raise ValueError(f'{key} is negative')

    hash_related_key = ['core_radius', 'x_list', 'y_list', 'coredeltas']
    cat_gene = ''
    for key in sorted(hash_related_key):
        if type(gene[key]) == list:
            for i in range(len(gene[key])):
                cat_gene += f'{round(gene[key][i], 3):.3f}'  # 有効数字2桁に丸める
        elif type(gene[key]) == float or type(gene[key]) == int:
            cat_gene += f'{round(gene[key], 3):.3f}'

    hashed_key = hash_string(cat_gene)

    return hashed_key
``` -->

ディレクトリ構造は次の通りです。
<!-- ![alt text](img/image.png) -->
<details><summary>ディレクトリ構造</summary>

```
/data/0/83d49d4fed84ef258826ea821ae6814a8ef6cf5535010145c4ed8ed3710cfd04
|--wavelength_1550nm
| |--2core.pdf
| |--M.dat
| |--cij
| | |--MSH1_MSH0
| | | |--c12_im
| | | |--c12_re
| | | |--c21_im
| | | |--c21_re
| | |--MSH2_MSH0
| | | |--c12_im
| | | |--c12_re
| | | |--c21_im
| | | |--c21_re
| |--couple
| | |--2core.cfg
| | |--2core.lps
| | |--_Er.gif
| | |--_mat.gif
| | |--_result.txt
| | |--mode-0-Ex.gif
| | |--mode-0-Ey.gif
| | |--mode-0-Ez.gif
| | |--mode-0-estHx.gif
| | |--mode-0-estHy.gif
| | |--mode-0-estHz.gif
| | |--mode-1-Ex.gif
| | |--mode-1-Ey.gif
| | |--mode-1-Ez.gif
| | |--mode-1-estHx.gif
| | |--mode-1-estHy.gif
| | |--mode-1-estHz.gif
| |--kij
| | |--MSH1_MSH2
| | | |--k12_abs
| | | |--k12_im
| | | |--k12_re
| | | |--k12_sci
| | | |--k21_abs
| | | |--k21_im
| | | |--k21_re
| | | |--k21_sci
| | |--MSH2_MSH1
| | | |--k12_abs
| | | |--k12_im
| | | |--k12_re
| | | |--k12_sci
| | | |--k21_abs
| | | |--k21_im
| | | |--k21_re
| | | |--k21_sci
| |--numpy_M.dat
| |--numpy_Mtilde.dat
| |--profiles.dat
| |--result.txt
| |--single1
| | |--2core.cfg
| | |--_Er.gif
| | |--_mat.gif
| | |--_result.txt
| | |--mode-0-Ex.gif
| | |--mode-0-Ey.gif
| | |--mode-0-Ez.gif
| | |--mode-0-estHx.gif
| | |--mode-0-estHy.gif
| | |--mode-0-estHz.gif
| |--single2
| | |--2core.cfg
| | |--_Er.gif
| | |--_mat.gif
| | |--_result.txt
| | |--mode-0-Ex.gif
| | |--mode-0-Ey.gif
| | |--mode-0-Ez.gif
| | |--mode-0-estHx.gif
| | |--mode-0-estHy.gif
| | |--mode-0-estHz.gif
| |--sympy_D.dat
| |--sympy_M_from_kij.dat
| |--sympy_P.dat
| |--tableD.dat
| |--tableP.dat
| |--tableU.dat
| |--tablekx.dat
| |--tableng.dat
```
</details>

#### 返り値
`result = calc_fiber()`の返り値`result`は辞書となる。
```python
result = {
    'couple_ng1': 1.449856368659995, 
    'couple_ng2': 1.449966748736736, 
    'gds': 184.09415213018656, 
    'neff_r': ['1.446778327208198', '1.446762495564402'], 
    'neff_i': ['0.000000000000000e+00', '0.000000000000000e+00'], 
    'k0_r[rad/um]': ['4.053667940115862', '4.053667940115862'], 
    'k0_i[rad/um]': ['0.000000000000000e+00', '0.000000000000000e+00'], 
    'kx_r[rad/um]': ['5.864758921458329', '5.864694745231435'], 
    'kx_i[rad/um]': ['0.000000000000000e+00', '0.000000000000000e+00'], 
    'ng_r': ['1.449856368659995', '1.449966748736736'], 
    'ng_i': ['0.000000000000000e+00', '0.000000000000000e+00'], 
    'Aeff[um^2]': ['1.693249940482153e+02', '1.653398877788967e+02'], 
    'single2_beta': 5.864726994285341, 
    'single2_ng': 1.449910908777932, 
    'single1_beta': 5.864726993356653, 
    'single1_ng': 1.449910908242495, 
    'kappa12': 3.1979750129e-05, 
    'kappa21': 3.1979474425e-05,
    'dirpath': '0/83d49d4fed84ef258826ea821ae6814a8ef6cf5535010145c4ed8ed3710cfd04'
    }
```

- `couple_ng{i}`: i番目のスーパーモードの群屈折率
- `gds`: 群遅延広がり (Group Delay Spread: GDS)。スーパーモードの群遅延時間$n_g$の分散で定義される。
  $$
  \mathrm{GDS} = \sqrt{\dfrac{1}{N}\sum_{i=1}^{N}(\tau_i - \tau_{\mathrm{ave}})^2},\quad \tau_i = L\dfrac{n_{gi}}{c},\quad \tau_{\mathrm{ave}} = \dfrac{1}{N}\sum_{i=1}^{N}\tau_i
  $$
- `neff_r`: スーパーモードの実効屈折率の実部を格納した配列
- `neff_i`: スーパーモードの実効屈折率の虚部を格納した配列
- `k0_r[rad/um]`: 自由空間波数の実部を格納した配列
- `k0_i[rad/um]`: 自由空間波数の虚部を格納した配列
- `kx_r[rad/um]`: スーパーモードの伝搬定数の実部を格納した配列
- `kx_i[rad/um]`: スーパーモードの伝搬定数の虚部を格納した配列
- `ng_r`: スーパーモードの群屈折率の実部を格納した配列
- `ng_i`: スーパーモードの群屈折率の虚部を格納した配列
- `Aeff[um^2]`: 実効断面積を格納した配列
- `single{i}_beta`: i番目の個別コアモードの伝搬定数
- `single{i}_ng`: i番目の個別コアモードの群屈折率
- `kappa{i}{j}`: コアi, j間の結合係数
- `dirpath`: 解析データを格納する`data`ディレクトリ内のパス。ディレクトリ名はハッシュ値である。

### pmpy.calc_gds
`calc_gds(structure_dict, gds_params_dict, num_loop, num_cpu = 1, num_mem = 1, filename_dict = {}, prefilename = 'prefile', PManalysis_dirname = "PManalysis_sato_quad_new5_neff", output_dirname = 'gds_result', graph = False)`
光ファイバの伝搬解析シミュレーションを行い、結果をファイルに出力します。関数自体の出力は`None`です。
#### 各引数の説明
- structure_dict
  - `structure_dict`は，解析したいステップインデックス型光ファイバの構造を記述した辞書です．以下の例のように，6つのキーを指定します．

  ```python
  structure_dict = {
      'num_of_core': 4,
      'core_radius': [4.55, 4.55, 4.55, 4.55],
      'x_list': [10, 0, -10, 0],
      'y_list': [0, 10, 0, -10],
      'coredeltas': [0.35, 0.35, 0.35, 0.35],
      'wavelength[um]': 1.55
  }
  ```

  - `num_of_core`はコア数を表す整数型 (int) 型のパラメータです．
  - `core_radius`はコア径を表すリスト型のパラメータで，リストの要素はfloat型です．単位はμmです．リストの長さはコア数と同じです．
  - `x_list`はコアのx座標を表すリスト型のパラメータで，リストの要素はfloat型です．単位はμmです．リストの長さはコア数と同じです．
  - `y_list`はコアのx座標を表すリスト型のパラメータで，リストの要素はfloat型です．単位はμmです．リストの長さはコア数と同じです．
  - `coredeltas`はクラッドに対するコアの比屈折率を表すリスト型のパラメータで，リストの要素はfloat型です．単位は%です．リストの長さはコア数と同じです．
  - `wavelength[um]`は解析波長を表すfloat型のパラメータで，単位はμmです．
- gds_params_dict
  - `gds_params_dict`は、伝搬解析のパラメータを記述した辞書です。以下の例のように，8つのキーを指定します．
  ```python
  gds_params_dict = {
                  'distance[m]': 1000,
                  'dz[m]': 0.001,
                  'Rbend[mm]': 150,
                  'RandomBend(sigma)[/mm]': 0,
                  'TwistRate[rad/m](1.0:PI)': 1.0,
                  'RandomTwist(sigma)[rad/m](1.0:PI)': 0,
                  'Lc[m]': 0.1,
                  'loop': 1
              }
  ```
  - `distance[m]`: 伝搬距離を表す整数型 (int) のパラメータです．単位はmです．
  - `dz[m]`: セグメント長を表すfloat型のパラメータです．単位はmです．
  - `Rbend[mm]`: 曲げ半径を表す整数型 (int) のパラメータです．単位はmmです．
  - `RandomBend(sigma)[/mm]`: ランダムな曲げを表すfloat型のパラメータです．単位はmです．
  - `TwistRate[rad/m](1.0:PI)`: ファイバの一定のねじれを表すfloat型のパラメータです．単位はrad/mです．入力した数値に対して円周率πが乗算されることに注意してください．例えば，1.0を入力すると，一定のねじれは1.0πとなります．
  - `RandomTwist(sigma)[rad/m](1.0:PI)`: ファイバのランダムなねじれを表すfloat型のパラメータです．単位はmです．入力した数値に対して円周率πが乗算されることに注意してください．例えば，1.0を入力すると，一定のねじれは1.0πとなります．
  - `Lc[m]`: ランダム位相誤差のランダム性を決定する相関長と呼ばれるfloat型のパラメータです．単位はmです．Lcは小さいほどランダム性が大きくなります．
  - `loop`: GDSの計算回数を表す整数型 (int) のパラメータです．
- num_loop
  - GDSの計算回数を指定するパラメータ。一般に、伝搬解析では正規分布に従うランダムな摂動が加わるため、計算回数を増やして平均を取ることで母集団の平均に近づけることができる。
- num_cpu = 1
  - 並列計算に使用するCPUの数。計算機の最大CPU数を超えないように設定する。num_cpuを増やすと、計算時間が短縮される。
- num_mem = 1
  - 計算に使用するメモリ量[GB]。計算機の最大メモリ量を超えないように設定する。
- filename_dict = {}
  - 伝搬解析に必要な設定ファイルの名前をカスタムするパラメータ。デフォルトでは、次の名前となっている。
    - `mpiexec.sh`
    - `hostname`
    - `param.ini`
    - `tableU.dat`
    - `tablekx.dat`
    - `tableng.dat`
  - 入力ファイル名がデフォルトと異なる場合には、`filename_dict`を次のように記述する。
  ```python
  filename_dict = {
        'mpiexec.sh': 'mpiexec_new.sh',
        'hostfile': 'hostfile_new',
        'param.ini': 'param_new.ini',
        'tableU.dat': 'tableU_new.dat',
        'tableng.dat': 'tableng_new.dat',
        'tablekx.dat': 'tablekx_new.dat'
    }
  ```
  ここでは、既存のファイル名に`_new`を付けたファイルを読み込むことを想定した。
- prefilename = 'prefile'
  - 結果を出力するディレクトリ名を設定。デフォルトでは`gds_params_dict`のデータを使って、`prefilename = f'prefile_rndBend{gds_params_dict["RandomBend"]}_rndTwist{gds_params_dict["RandomTwist"]}'`が設定される。
- PManalysis_dirname = "PManalysis_sato_quad_new5_neff"
  - 伝搬解析に用いる実行ファイルのディレクトリ名を指定する。サポート中のディレクトリ名は`/home/konishi/lib/Solver/`から確認できる。2024年6月4日現在、次のディレクトリ名がサポートされている。
  ```python
  [
      'PManalysis_indivisual', 
      'PManalysis_sato_quad_new5',
      'PManalysis_sato_quad_new5_neff',
      'PManalysis_indivisual_ip_im', 
      'PManalysis_couple_ip_im', 
      'PManalysis_couple_ip_im_neff_record',
      'PManalysis_couple_ip_im_neff',
      'PManalysis_couple_neff',
      'PManalysis_indivisual_neff',
      'PManalysis_konishi_indivisual',
      'PManalysis_konishi_couple',
      'PManalysis_konishi_indivisual_new'
  ]
  ``` 
  - デフォルトでは、`PManalysis_sato_quad_new5_neff`が用いられており、主な仕様は次のとおりである。
    - 相関長によるランダム位相誤差を考慮
    - ランダム位相誤差の周波数依存性は考慮しない
    - ランダム位相誤差はスーパーモードに乗算
    - 実効屈折率の伝搬距離依存性データを出力
    - GDSの伝搬距離依存性データを出力
    - 群遅延時間の伝搬距離依存性データを出力
    - GDSスロープの伝搬距離依存性データを出力
- output_dirname = 'gds_result'
  - 出力ディレクトリの名前を設定する。デフォルトでは`gds_result`になる。
- graph = False
  - グラフを出力する場合はTrue、しない場合はFalseに設定する。デフォルトではFalseに設定されている。
#### 出力ファイルの場所
- 伝搬計算の結果を格納しているディレクトリは次のようになっている。
`/data/構造特有のハッシュ値/wavelength_{波長}nm/gds_result/prefilename/TwistRate{ツイスト率}/pd{伝搬距離}_dz{セグメント長}_rbend{曲げ半径}_Lc{相関長}`
例：`~/32ed8ee40e9fbbc510855d1a9ba715be6df6fb5252c6316d1b918c0a0c8abd2c/wavelength_1550nm/gds_result/_prefile_sato_quad_new5_neff_tr1.0_Lc0/TwistRate1.0/pd1000_dz0.001_rbend10000_Lc0`
#### 返り値
`calc_gds`の返り値は`None`である。計算した結果はすべてファイルに保存される。

### fiber.calc_rbend_gds


### fiber.generate_hash(gene_dict)

<!-- In-product release notes styles.  Do not modify without also modifying regex in gulpfile.common.js -->
<a id="scroll-to-top" role="button" aria-label="scroll to top" onclick="scroll(0,0)"><span class="icon"></span></a>
<link rel="stylesheet" type="text/css" href="inproduct_releasenotes.css"/>
